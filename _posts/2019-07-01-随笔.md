# 刷题心得

- python的list默认支持栈的方法pop()和append()（和push同一个功能）
- "in-place"的题，想到指针
- 物理层调制器作用：将数字信号转换成模拟信号
- leetcode 53：maxSubArray

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int max = nums[0];
        for(int i=1; i<n; i++){
            if(dp[i-1] > 0)
                dp[i] = dp[i-1] + nums[i];
            else
                dp[i] = nums[i];
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```

- ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170715202503459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- ```java
  A * "1+1+1+1+1+1+1+1 =？" *
  
  A : "上面等式的值是多少"
  B : *计算* "8!"
  
  A *在上面等式的左边写上 "1+" *
  A : "此时等式的值为多少"
  B : *quickly* "9!"
  A : "你怎么这么快就知道答案了"
  A : "只要在8的基础上加1就行了"
  A : "所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过
     的解来节省时间'"
  ```

- **动态规划算法的核心**:记住已经解决过的子问题的解。

# 并查集

- 用于解决动态连通性问题的逻辑数据结构

- 包含两种操作：union()和connect()

- union(x,y)给x,y之间添加一条connection

- find(x,y)返回x和y之间是否连通，True/False

- quickFind：

  ![1564886384223](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564886384223.png)

- quickUnion：

  - 想一想为什么每一次union都用是**连通分量的根指向联通分量的根**，这个步骤是提升效率的关键
  - ![1564887048334](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564887048334.png)
  - ![1564887375654](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564887375654.png)

- quick-union和quick-find都不行

- 改进：

  1. 每个连通分量引入权重（每个分量上的节点数），以此避免树线性化

  2. 每一个union操作，都将**权重小的连通分量连在另一颗树上**

     ![1564887609295](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564887609295.png)

     - 复杂度分析：

       ![1564888317382](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564888317382.png)

     - 再改进一下？？：引入路径压缩

       - ![1564888496570](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1564888496570.png)
         - 加入一行代码，每次让节点指向他的祖父节点，基本就能将整棵树展平



- 最近生活过的不太规律，该学习的时候一定得找一个没地方躺的地方不然一趟就是大半天..
- 之后的计划：两周内把leetcode100题刷完，Princeton算法课跟上，最后，小程序要急工赶完。