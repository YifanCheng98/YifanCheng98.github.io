# Linux内核设计与实现

- 一切皆文件：使得对设备和对数据的操作可以通过同一套系统调用去实现：open(), read(), write(), lseek()

  - 似乎Socket不是文件

- 任何CPU在任何时间点一定在做三者之一：
  - ![1565675023793](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565675023793.png)
  - 用户空间执行用户进程
  - 内核空间执行系统调用（处于进程上下文，代表某个特定的进程执行）
  - 内核空间执行中断上下文，处理某个特定的中断

- 单内核与微内核：
  - 单内核将所有的内核服务都以单个静态二进制文件的形式存放于磁盘，在同一个大内核地址空间上运行。**简单、性能高**、**内核间通信微不足道**（直接通过内存共享来通信，因为在同一个地址空间）。大多数Unix系统都是单内核
  - 微内核的功能被划分为多个独立的过程，每个过程叫做一个server。所有服务器都保持独立运行在各自的地址空间上。因此不是像单模块内核那样直接调用函数，而是通过**消息传递****处理微内核通信**。采用IPC机制。**开销大**

- Linux是单内核系统，但吸取了微内核的精华，带来模块式设计、抢占式内核、支持内核线程以及动态装在内核模块的能力。通过函数调用来进行通信

- 内核特点：
  1. 抢占式
  2. 线程支持
  3. 动态内核加载
  4. SMP

- 用户态的mode bit 1 . 内核态的mode bit 0

- 单内核OS的arch:
  ![1565731940619](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565731940619.png)

  （服务全部位于内核态，通过system call向外界开放）

- 微内核OS的arch：
  ![1565749847322](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565749847322.png)

- system call：nThree
  most common APIs are Win32 API for Windows, **POSIX API for POSIX-based systems**
  (including virtually all versions of UNIX, Linux, and Mac OS X), and Java API
  for the Java virtual machine (JVM)

  - 系统调用的三种传参方式
    1. 直接传入寄存器
    2. 参数值存入内存，然后将块地址/页地址作为参数传递
    3. 参数直接压入程序内存栈中

- **Process**

  1. Program Code: text section
  2. Program Counter
  3. Stack:temporary data
  4. Data section
  5. Heap
  6. register set

- **进程的内存布局**：
  ![1565751579935](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565751579935.png)

- 进程五状态：

  - start
  - ready
  - running
  - waiting
  - terminated
  - ![1565751702873](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565751702873.png)

- 操作系统用PCB来代表一个进程Process Control Block

  - ![1565751759063](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565751759063.png)

- 上下文切换：
  ![1565752233325](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565752233325.png)

- CPU调度怎么实现：
  - 维持一些进程调度队列:
    1. 任务队列（所有的Process）
    2. 就绪队列
    3. 正在I/O队列
- **短期调度器（CPU Scheduler）：选择下一步该执行的进程并且分配CPU**
- **长期调度器(Job Scheduler)：选择放入就绪队列的进程，用来控制并发度？？？**
- 进程份以下两种：
  - I/O bound process：做IO时间比占用CPU时间多
  - CPU bound process：反之
- **UNIX:整个进程创建的过程：0号进程->1号内核进程->1号用户进程（init进程）->getty进程->shell进程**
- **1号init内核进程是处于内核态的0号进程的子进程。** pstree在看的时候看不到0号进程，因为是内核态进程。实际上0号进程也是所有进程的祖先‘
- 另一个一号进程：用户态一号进程
- 孤儿进程被用户态一号进程领养



- **fork(), exec()(给子进程重新分配地址空间)**
- **子进程调用exit()死亡，父进程调用wait()为其回收资源**
- **父进程也可以调用abort()来杀死紫禁城**
- **孤儿进程、僵尸进程**



- IPC方式
  - shared memory
  - message passing
    - direct pass
      - send(p,message)
      - receive(q)
    - indirect pass
      - 以邮箱做中介：
      - send(mailbox,message)
      - receive(mailbox,message)
      - 这种方式也叫buffering





- Thread
  - Thread ID
  - PC
  - register set
  - stack
  - 一些数据在同进程线程间共享共享
  - ![1565759979657](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565759979657.png)
  - 线程的创建要轻量级很多



- 多线程模型：
  - 首先线程分为用户线程和内核线程
  - 用户线程和内核线程之间有如下数量关系（**这个没看懂**）：
  - 线程是独立调度的基本单位，进程是资源拥有的基本单位
    - 多对一
    - 一对一
      ![1565807022110](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565807022110.png)
    - 一对多

- Unix信号
  - 信号是UNIX系统中用来通知进程特定发生了特定事件的机制
  - 信号句柄：接收到信号后的处理函数
    - OS对每种信号句柄都有一种默认的实现
    - 用户可以自定义实现去重写OS的信号句柄
- thread-local storage(TLS)：允许每一个线程拥有一份数据拷贝
- Linux通过clone()系统调用来创建一个线程



## CPU调度

- CPU burst的概念：一个CPU burst代表占用CPU一个执行cycle的时间

- CPU-burst的分布：
  ![1565810308043](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565810308043.png)

- **CPU调度器：**

  - 短期调度器
  - 中期调度器
  - 长期调度器

- **抢占式/非抢占式的调度**：

  ![1565810454001](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565810454001.png)

  - **简单来说**，非抢占式调度下一个占据CPU的线程会一直被执行直到终止或者做I/O。而抢占式调度下，如果出现高优先级或者xxx的进程，可以直接把原进程挤出CPU，变成ready进程

- **Dispatcher：进程分派器**，在running进程切换时发挥以下作用：

  1. 进程上下文切换
  2. 切换到用户态
  3. PC跳转到下一个进程的起始位置

- **CPU调度原则**：

  - CPU利用率
  - 吞吐量
  - 周转时间turnaround time:执行特定进程的时间（包含运行时间和等待时间）
  - 等待时间
  - 响应时间

- 例题：
  ![1565811137672](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565811137672.png)

### CPU调度算法

1. FIFS先来先服务：非抢占式；缺点会导致短耗时进程等待过长时间
2. Shortest job First：如果时间相同，则按照FCFS原则处理
3. Shortest remaining time first：同上
4. 优先级调度：数越小优先级越高，分为抢占式和非抢占式两种；缺点：低优先级进程会挨饿starvation，解决方案：aging，随着时间增加优先级
5. 时间片轮转：进程用完一段时间就插入ready queue末尾；**根据经验，80％的CPUburst应该比time quantum短。**
6. 多级队列:比如：就绪队列分为**前端和后台**两个队列。每个队列有其各自的调度算法：前端RR，后端FCFS
7. **多级反馈队列**：在多级队列基础上，允许进程在队列间切换
   ![1565812753634](C:\Users\10421\AppData\Roaming\Typora\typora-user-images\1565812753634.png)

- 多CPU情况下的调度：
  - 非对称多进程：一个CPU处理所有CPU的调度
  - 对称多进程SMP：每个CPU负责各自的调度，这个用的比较多
    - 在SMP系统中，CPU之间的负载均衡非常重要



- Windows使用优先级队列的抢占式调度

## Synchronization

- race condition:为了避免race conditions,并发进程/线程必须要进行同步处理
- **critical section:资源临界区，一次只能被一个对象访问.需满足的条件**
  1. Mutual Exclusion:互斥、忙则等待
  2. Progress：空闲让进
  3. Bounded waiting：有限等待
- **同步机制** 
  1. Software-based
  2. Hardware-based
  3. Semaphore
     - wait()和signal()。P()V()操作
  4. Monitor管程，即提供好同步的实现，提供API



- 死锁的必要条件
  1. 互斥
  2. hold and wait
  3. No preemption
  4. Circular wait
- 如何预防死锁：从四个必要条件入手
- **银行家算法：计算一系列资源请求是否安全**